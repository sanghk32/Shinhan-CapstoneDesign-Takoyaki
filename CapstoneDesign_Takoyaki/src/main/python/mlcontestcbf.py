# -*- coding: utf-8 -*-
"""mlcontestCBF.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KdlPZrU5xJVSmVZbr5Tg73weVAqfc4C1
"""

import mysql.connector
import sys
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LinearRegression


# MySQL 연결 설정
db_params = {
    'host': 'AWS_RDS_ADDRESS',
    'user': 'DBID',
    'password': 'DBPW',
    'database': 'DATABASE',
    'port': 3306  # MySQL의 기본 포트
}

# 데이터베이스 연결
connection = mysql.connector.connect(**db_params)

# 커서 생성
cursor = connection.cursor()

# SQL 쿼리 작성 (Amazon RDS의 데이터를 가져오는 적절한 쿼리로 수정)
sql_query = "SELECT * FROM vector_contDetail"   # 여기서 'your_table'을 Amazon RDS의 실제 테이블 이름으로 수정

# SQL 쿼리 실행
cursor.execute(sql_query)

# 데이터 불러오기
data = cursor.fetchall()

# 테이블의 열 이름(칼럼 이름) 가져오기
column_names = [i[0] for i in cursor.description]

# 데이터프레임 생성
df = pd.DataFrame(data, columns=column_names)

# 사용자 아이디 저장
user_id = sys.stdin.readline().strip()

# SQL 쿼리 작성 (reco_tb에서 wantedAuthNo 가져오기)
sql_query2 = "SELECT * FROM contUserBookmark where id = %s"

# SQL 쿼리 실행
cursor.execute(sql_query2,(user_id,))

# 데이터 불러오기
data2 = cursor.fetchall()

df2 = pd.DataFrame(data2, columns=['id', 'contid', 'name', 'category','agent', 'rating'])
df2 = df2.drop(['id', 'name', 'category', 'agent'], axis=1)

# 연결과 커서 닫기
cursor.close()
connection.close()

# contid로 벡터 정보 불러오기
df2 = pd.merge(df, df2, on='contid', how='inner')

#
df2['rating'] = pd.to_numeric(df2['rating'], errors='coerce')

# 'rating' 칼럼을 예측하기 위해 데이터를 나눕니다.
X = df2.drop(['contid', 'category', 'agent', 'rating'],axis=1)
y = df2['rating']

# 다중 선형 회귀 모델을 생성하고 학습합니다
model = LinearRegression()
model.fit(X, y)

# 모델을 사용하여 df의 'rating' 칼럼을 예측합니다.
X_df = df.drop(['contid', 'category', 'agent'],axis=1)
df['pred_rating'] = model.predict(X_df)

# 'pred_rating' 열의 각 값을 df2 데이터프레임의 'rating' 열의 값과 비교하여, 각 값과 가장 가까운 'rating' 값을 찾아서 해당 값을 'pred_rating'열의 새로운 값으로 설정
df['pred_rating'] = df['pred_rating'].apply(lambda x: min(df2['rating'], key=lambda value: abs(value - x)))

# 'pred_rating' 열을 기준으로 내림차순 정렬
df = df.sort_values(by='pred_rating', ascending=False)

# df 데이터프레임에서 wantedAuthNo의 값을 pred_rating이 높은 순서대로 출력 pred_rating이 3.5이상인 경우에만 출력한다. / 공모전이나 대외활동 같은 경우 3.5 이상보다 기준치를 낮추거나 if문 제거도 고려
for index, row in df.iterrows():
    if row['pred_rating']>=3.0:
        print("contid:", row['contid'])
        print("pred_rating:", row['pred_rating'])